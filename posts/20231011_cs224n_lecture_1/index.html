<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-10-11">
<meta name="description" content="Stanford University CS224N Lecture 1 のスライドの解説、メインのテーマは授業の紹介とWord2vec">

<title>Stanford CS224N 深層学習による自然言語処理 Lecture 1 まとめ – blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-57476271c5f0467c372e20ff5d25630e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-edc0777d93aca8f084c81dbc6fa27f8b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-56TE34D1Z4"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-56TE34D1Z4', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="http://www.linkedin.com/in/jiang-dayuan"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#前書き" id="toc-前書き" class="nav-link active" data-scroll-target="#前書き">前書き</a>
  <ul class="collapse">
  <li><a href="#全体のロジ" id="toc-全体のロジ" class="nav-link" data-scroll-target="#全体のロジ">全体のロジ</a></li>
  <li><a href="#人間の言語と単語の意味" id="toc-人間の言語と単語の意味" class="nav-link" data-scroll-target="#人間の言語と単語の意味">人間の言語と単語の意味</a></li>
  <li><a href="#word2vecの紹介" id="toc-word2vecの紹介" class="nav-link" data-scroll-target="#word2vecの紹介">Word2vecの紹介</a></li>
  <li><a href="#word2vec目的関数の最適化" id="toc-word2vec目的関数の最適化" class="nav-link" data-scroll-target="#word2vec目的関数の最適化">Word2vec目的関数の最適化</a></li>
  <li><a href="#最適化の基礎" id="toc-最適化の基礎" class="nav-link" data-scroll-target="#最適化の基礎">最適化の基礎</a></li>
  <li><a href="#word-vectorを実際に見る" id="toc-word-vectorを実際に見る" class="nav-link" data-scroll-target="#word-vectorを実際に見る">Word Vectorを実際に見る</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Stanford CS224N 深層学習による自然言語処理 Lecture 1 まとめ</h1>
  <div class="quarto-categories">
    <div class="quarto-category">NLP</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 11, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="前書き" class="level1">
<h1>前書き</h1>
<p><a href="https://web.stanford.edu/class/cs224n/">Stanford University CS224N</a>は深層学習による自然言語処理の授業です。授業のビデオ、使用したスライド、また宿題等、授業のすべてがインタネットで公開されています。</p>
<p>この授業は情報理工の学生だけではなく、言語学の学生も対象となっているため、入門するための前提知識を細々と教えています。自然言語の技術的なところだけではなく、自然言語の本質等のところも触れています。</p>
<p>2019年にまた素人の私はそれを勉強し、実践としてKaggleのコンペで金メダルを取得しました。また、当時はGPT2がすでに出ていて、最後の授業の中で、未来への展望の中で、GPT2が触れていて、将来は巨大なGPTモデルですべての課題が解決されるのではないかとの話がありました。GPT4がNLP業界を席巻している現在から振り返て見ると、当時はこの授業から相当先進なことを学んだ気がします。</p>
<p>一方、それは4年前の授業なので、2023年の今どんなアップデートがあるかは気になります。また、以前勉強会でこの授業が学びましたが、メモなどのことを残らなかったです。そのため、復習兼新しいことのキャッチアップの目的で、CS224N 2023の授業を1回学び直して、各スライドに何を話したかを記録したいと思います。</p>
<p>それでは、最初のLecture 1を始めましょう。</p>
<p><img src="images/0001 Large.jpeg" class="img-fluid"></p>
<section id="全体のロジ" class="level2">
<h2 class="anchored" data-anchor-id="全体のロジ">全体のロジ</h2>
<p><img src="images/0002 Large.jpeg" class="img-fluid"></p>
<p>レクチャーの構成は上のスライドのように、授業の全体像の紹介と言語の概念の紹介を行った上で、本題となるWord2vecの説明を行います。</p>
<p><img src="images/0003 Large.jpeg" class="img-fluid">授業の基本情報の紹介です。このスライトを無視して良いです。</p>
<p><img src="images/0004 Large.jpeg" class="img-fluid"></p>
<p>メンバーの構成。このスライトも無視して良いです。</p>
<p><img src="images/0005 Large.jpeg" class="img-fluid">この授業で教えることは主に3つです。</p>
<ol type="1">
<li>ベーシックとなる重要なコンセプト：Word Vector, RNN, Transfromers等。</li>
<li>自然言語の全体像、またコンピューターでそれを理解と生成するための難しさ</li>
<li>NLPの主な課題についてPyTorchでシステムを構築して解決する能力</li>
</ol>
<p><img src="images/0006 Large.jpeg" class="img-fluid"> またロジの説明です。無視してよいです。</p>
<p><img src="images/0007 Large.jpeg" class="img-fluid">宿題は5つあります。 1,2はPythonを使って基礎なプログラミングを行います。3,4,5はPyTorchを使って実際の問題を解決します。</p>
</section>
<section id="人間の言語と単語の意味" class="level2">
<h2 class="anchored" data-anchor-id="人間の言語と単語の意味">人間の言語と単語の意味</h2>
<p><img src="images/0008 Large.jpeg" class="img-fluid"> <img src="images/0009 Large.jpeg" class="img-fluid"> <img src="images/0010 Large.jpeg" class="img-fluid"></p>
<p><img src="images/0011 Large.jpeg" class="img-fluid">近年の機械翻訳の新しい手法により、機械翻訳はかなり機能するようになりました。 何千年もの間、他の言語を学ぶことは多大な努力を必要とするタスクでしたが、今ではプラウザを開くことで容易にできるようになります。自然言語処理の最大の発展はこのような機械翻訳の進歩です。</p>
<p><img src="images/0012 Large.jpeg" class="img-fluid"> OpenAIがリリースしたGPT-3は、ユニバーサルモデルへの第一歩として注目されています。</p>
<p>ユニバーサルモデルとは、世界の知識、人間の言語、タスクの実行方法などを学習した大規模モデルです。その一個のモデルで様々なことを行うことができます。</p>
<p>GPT-3には、与えられた例に基づいて特定のタスクを実行する能力もあります。例えば、「窓を割った」という文を「何を割ったか？」という質問に変えるなどです。さらに、GPT-3は人間の言語をSQLに翻訳することも可能で、これによりデータベース操作が容易になります。</p>
<p><img src="images/0013 Large.jpeg" class="img-fluid"> 新しく出たChatGPTはより性能がよくたくさんのことができます。</p>
<p><img src="images/0014 Large.jpeg" class="img-fluid"></p>
<p><img src="images/0015 Large.jpeg" class="img-fluid">普通に与えられた自然言語のタスクに対してこなすことができます。例えば、Latexへの変換。</p>
<p><img src="images/0016 Large.jpeg" class="img-fluid">言葉の意味は、言葉（記号や象徴）とそれが指し示すもの（アイデアや物）の間の結びつきとして考えられます。例えば、「椅子」という言葉の意味は、「椅子」の集合体を指します。これは「表示的意味論」(Denotational Semantics)と呼ばれます。</p>
<p><img src="images/0017 Large.jpeg" class="img-fluid"> しかし、この理論を実装するのが難しいため、自然言語処理システムでは、辞書や類語辞典などのリソースを利用して意味を扱 うことが一般的です。特に、同義語の集合や上位語（ISA関係）を組織化したWordNetがよく使われます。上位語を通じて、「パンダ」が「肉食動物」であり、「哺乳動物」であるといった関係性を理解することができます。</p>
<p><img src="images/0018 Large.jpeg" class="img-fluid">WordNetなどの人間が構築したツールは、NLPのリソースとして有用ですが、ニュアンスや現代の言葉遣いを十分にカバーしていないという欠点があります。例えば、「proficient」が「good」の同義語としてリストされていますが、これは文脈によりそうではない場合があります。また、新しい用語や現代の俗語は含まれていないため、ツールは常に最新の状態を保つことが難しいです。</p>
<p><img src="images/0019 Large.jpeg" class="img-fluid">伝統的なNLPの問題点は、単語を離散的な記号(One-hot vector)として扱うことです。これは、各単語が異なるものとして表現されるため、大量の単語を表現するためには巨大なベクトルが必要となります。例えば、高校英語の辞書には約25万語が含まれていますが、実際の言語にはもっと多くの単語が存在します。したがって、少なくとも50万次元のベクトルが必要となります。</p>
<p><img src="images/0020 Large.jpeg" class="img-fluid">また、単語の類似度も測りにくい問題があります。例えば、ウェブ検索で「Seattle motel」を検索した場合、システムは「Seattle hotel」を含むドキュメントもマッチさせたいと考えます。しかし、One-hot Vectorで単語表現する場合は、ベクトルの内積は0になりまして、類似度を計算できません。</p>
<p>これを解決するための古い方法として、WordNetの同義語を使用したり、意味の重複を持つ単語の表現を構築したりする方法がありましたが、これらは不完全性から大きな失敗を招きました。そこで現代の深層学習方法を紹介します。これは、実数値のベクトルに類似性をエンコードする方法です。</p>
<p><img src="images/0021 Large.jpeg" class="img-fluid"></p>
<p>まず分布意味論について紹介します。分布意味論とは、単語の意味をその単語が頻繁に近くに現れる単語によって定義するという考え方です。この考え方は、統計的および深層学習の自然言語処理で広く用いられています。</p>
<p>具体的には、ある単語（例えば「banking」）がテキスト中に現れるたびに、その近くに現れる単語（文脈）を集め、文脈がその単語の意味を表現すると考えます。</p>
<p><img src="images/0022 Large.jpeg" class="img-fluid">Word Vectorとは、各単語を表す実数値ベクトルのことです。ベクトルは通常300次元で、各単語の意味はその300次元全体に分散しています。中身は実数値なので、単語の類似度をベクトルのDot productで計算できます。</p>
<p><img src="images/0023 Large.jpeg" class="img-fluid"> このベクトル空間は、人間が視覚的に理解するのは難しいため、2次元の投影で表示します。この投影により、似たような単語が近くにグループ化されていることがわかります。例えば、国名や国籍を表す単語、動詞などがそれぞれ近くにグループ化されています。このように、分布モデルを用いることで、単語の意味や関連性を表現することが可能になります。</p>
</section>
<section id="word2vecの紹介" class="level2">
<h2 class="anchored" data-anchor-id="word2vecの紹介">Word2vecの紹介</h2>
<p><img src="images/0024 Large.jpeg" class="img-fluid">word2vecは2013年にTomas Mikolovらから提案した単語のベクトル表現を学習するフレームワークです。</p>
<p>各単語の良いベクトルを求めるために、大量のテキストから単語ベクトルを学習します。これは、他の単語のコンテキストでどの単語が出現するかを予測する分布的な類似性のタスクを行うことで可能です。具体的には、テキスト中の任意の時点で中心語とその周囲の文脈語を選び、現在のモデルに基づいて文脈語の出現確率を計算します。その後、実際にその中心語の文脈で出現した単語に対して確率を最大化するように単語ベクトルを調整します。</p>
<p><img src="images/0025 Large.jpeg" class="img-fluid"></p>
<p><img src="images/0026 Large.jpeg" class="img-fluid"></p>
<p>P25とP26はもっと具体的な例です。例えば中心語は「into」の場合は、周りに出ている文脈語の出現確率をモデルにより計算できます。出現確率が高い方が良いです。次にどのようにそのモデルを学習することを説明します。</p>
<p><img src="images/0027 Large.jpeg" class="img-fluid">Word2vecがやっていることは、テキストのコーパス内の各位置について、中心の単語WJが与えられた場合、固定サイズMのウィンドウ内の文脈語を予測することです。1個目の式がそれを表しています。θはモデルのパラメーターです。</p>
<p>コンテキスト内で発生する単語に高い確率を与えたいのです。しかし、標準的な手法に従って、積を扱うよりも和を扱った方が簡単なので、対数尤度を使用します。対数尤度を取ると、すべての積が和に変わります。また、平均対数尤度を扱うため、コーパス内の単語数に対する1/t項をここに追加します。<br>
<br>
また、目的関数を最大化するよりも最小化する方が好ましいため、マイナス符号を追加します。したがって、この目的関数J（θ）を最小化することにより、予測精度を最大化することになります。</p>
</section>
<section id="word2vec目的関数の最適化" class="level2">
<h2 class="anchored" data-anchor-id="word2vec目的関数の最適化">Word2vec目的関数の最適化</h2>
<p><img src="images/0028 Large.jpeg" class="img-fluid"> 目的関数がありましたが、文脈語の確率をどう計算するか？それを計算するためには、中心語と文脈語のベクトルを用意して、ピンク色の式で文脈語の出現確率を計算します。P30にでそれの詳細を説明します。</p>
<p><img src="images/0029 Large.jpeg" class="img-fluid"> <img src="images/0030 Large.jpeg" class="img-fluid">①オレンジ色の式は2つの単語ベクトルの内積を取っていることは類似度を測っていることです。<br>
②内積はマイナスにもなるため、指数をとることで強制にプラスにします。<br>
③分母の部分は、すべての文脈語と中心語との類似度の足し算です。</p>
<p>このようにして、単語間の類似度を確率分布に変換します。例えば、一番望ましい場合は、文脈語と中心語の類似度は1、他の単語と中心語の類似度は0のことです。それ場合のP(O|C)は1になります。</p>
<p>このプロセス全体で使用される関数は「ソフトマックス関数」と呼ばれます。ソフトマックス関数は、任意の実数ベクトルを0から1の範囲の値に変換します。この関数は、大きな値を強調し、最も類似したものに最も多くの確率を割り当てる一方で、何らかの類似性を持つ全てのものに少なくとも何らかの確率を割り当てます。</p>
<p><img src="images/0031 Large.jpeg" class="img-fluid"> パラメーターを最適化する際に勾配降下法を利用します。</p>
<p>ここでの注意点としては、中心語と文脈語のベクトルが別れていることです。例えば、Zebraという単語にC(Zebra)とO(Zebra)の2つのベクトルがありまして、Zebraは中心語のとこにはC(Zebra)を利用し、文脈語のときはO(Zebra)を利用します。(パラメーターをシェアしても良いですが、計算の簡単化のためにあえて分けています。)</p>
<p>次のP32からP32は最適化する際に目的関数の微分を計算する具体的なステップです。計算に興味がない方は無視して良いです。</p>
<p><img src="images/0032 Large.jpeg" class="img-fluid"> <img src="images/0033 Large.jpeg" class="img-fluid"> <img src="images/0034 Large.jpeg" class="img-fluid"></p>
<p><img src="images/0035 Large.jpeg" class="img-fluid"> 面白いのは、目的関数を微分した結果は文脈語ベクトルの観測値と期待値の差分になります。観測値と期待値が一致することはモデルがよく学習できていることです。</p>
<p>ちなみに、Softmax系のモデルを最適化する際にいつもこのような観測値と期待値の差分になります。</p>
</section>
<section id="最適化の基礎" class="level2">
<h2 class="anchored" data-anchor-id="最適化の基礎">最適化の基礎</h2>
<p><img src="images/0036 Large.jpeg" class="img-fluid">ワードベクトルの学習方法については、ランダムなワードベクトルから始め、損失関数を定義し、勾配降下法を用いて損失関数を最小化するようにベクトルを更新していきます。具体的には、現在のパラメータから勾配を計算し、その負の方向に小さなステップを進めることで、損失関数を最小化する方向に進んでいきます。</p>
<p>ステップサイズは調整可能で、小さすぎると計算が多くなり、大きすぎると最適解に収束しない可能性があります。また、ニューラルネットワークは一般的に凸ではないため、最適解が一意でない可能性がありますが、実際には問題なく動作します。</p>
<p>(勾配降下法について詳しく知りたい方は、CourseraのAndrew Ng先生の機械学習の授業の受講を強くおすすめします。)</p>
<p><img src="images/0037 Large.jpeg" class="img-fluid"></p>
<p>勾配降下法とは、現在のパラメータθの値を持ち、学習率またはステップサイズαを使用して勾配の負の方向に少し移動します。これにより、新しいパラメータ値が得られます。これらはベクトルであり、各個別のパラメータは、そのパラメータに対するjの偏微分を計算することで少し更新されます。これが単純な勾配降下法のアルゴリズムです。</p>
<p><img src="images/0038 Large.jpeg" class="img-fluid">全コーパスを用いて損失関数やその勾配を計算すると、非常に時間がかかり、一度の勾配更新に長い時間を要するため、最適化が極めて遅くなります。そのため、ニューラルネットワークではほぼ100%の場合、勾配降下法ではなく確率的勾配降下法(SGD)が用いられます。SGDでは、全コーパスに基づく勾配の推定ではなく、一つまたは少数の中心語に基づく勾配の推定を行います。この推定はノイズが多く不完全ですが、それを用いてパラメータを更新します。これにより、一度のコーパス通過で何十億ものパラメータ更新が可能となり、学習速度が大幅に向上します。</p>
<p>また、SGDは学習過程で揺れ動く特性がありますが、これが複雑なネットワークではより良い解を学習することを可能にします。したがって、確率的勾配降下法は計算速度を大幅に向上させるだけでなく、より良い結果を得ることができます。</p>
</section>
<section id="word-vectorを実際に見る" class="level2">
<h2 class="anchored" data-anchor-id="word-vectorを実際に見る">Word Vectorを実際に見る</h2>
<p><img src="images/0039 Large.jpeg" class="img-fluid"> 最後はWord Vectorに関する簡単なデモになります。スライドがないため、説明は割愛します。</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/jiang\.jp");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="AlbertRapp/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>