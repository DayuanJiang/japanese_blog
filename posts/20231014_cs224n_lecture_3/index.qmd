---
title: "Stanford CS224N 深層学習による自然言語処理 Lecture 3 まとめ"
date: 2023-10-15
description-meta: "Stanford University CS224N Lecture 3 のスライドの解説、メインのテーマはニューラルネットワークの数学的な詳細"
categories: [NLP]
---

今日は3回目のレクチャーです。今回の授業は自然言語処理とは関係しなくて、深層学習の内容になります。その辺に詳しい方はこのレクチャーを飛ばして良いです。

![](images/0001.jpeg)

![](images/0002.jpeg)

今回の講義では、ニューラルネットワークの学習に関する数学的詳細について説明します。まず、ニューラルネットワークの訓練のための勾配を手作業でどのように計算するかを見ていきます。次に、それがよりアルゴリズム的にどのように行われるかを見ていきます。つまり、Back propagationのことです。

また、シラバスのSuggested Readingの部分にはいくつかの補足資料がありまして、そちらを見るのは強くおすすめします。

![](images/0003.jpeg)

NERは、テキスト内の単語を人名、場所、製品、日付、時間などのエンティティカテゴリにラベル付けするタスクです。単純な辞書を使うだけではなく、文脈を利用して正確な認識を行う必要があります。

![](images/0004.jpeg)

一番シンプルのやりかたはウィンドウサイズを定義し(例えば5)、5つのワードベクトルを横で繋いて、それをニューラルネットワーク層に通してロジスティック分類器を作ることです。それで中心にある単語は地名かを判断します。人名や他のことを判断するときは、ぞれぞれ2値分類器を作ります。

![](images/0005.jpeg)

このスライトをに詳細な計算方法を示しています。インプット`x`をまず隠れ層を通して`h`になります。また、ベクトルを数値に変換するために`u`と内積を取ってスケールの`s`になります。`s`をロジスティクス関数で0から1の数値に変換します。

![](images/0006.jpeg)

上記のモデルを学習するために、パラメーターから目的関数の偏微分を差し引くする必要があります。その計算は手動と自動の2つのやり方があります。それもこれから説明することです。

## 行列微分計算

![](images/0007.jpeg)

![](images/0008.jpeg)

多変数微分は、行列を使用すると単一変数の微分と同じです。行列を使わないよりもはるかに高速で有用ですが、そこまで直感ではありません。

![](images/0009.jpeg)

例えば、 $f(x)=x^3$ の式があります。その式の勾配は微分のことです。つまり、インプットを少し変えると、アウトプットをどうなるかのことです。

![](images/0010.jpeg)

関数に複数のインプットがある場合は、各インプットの偏微分はベクトルになります。

![](images/0011.jpeg)

関数に複数のインプットと複数のアウトプットを持つ場合は、各アウトプットが各インプットに対する偏微分は行列になります。例えば、1行目の1列はアウトプット1がインプット1に対す偏微分です。それはヤコビ行列と言います。

![](images/0012.jpeg)

複数の関数をパイプラインで組み合わせしている場合は、微分は各関数の微分の掛け算です。ヤコビ行列の時も同じです。

![](images/0017.jpeg)

例えば、Sigmoid等の活性化関数は入力値に対して個別に適用するため、ヤコブ行列の中の行と列が一致しない場合は偏微分は0で、一致する場合のみ偏微分が計算されます。最終結果が対角線行列になります。

![](images/0021.jpeg)

他もいくつかの例を上げました。

![](images/0023.jpeg)

先程の簡単なネットワークに戻します。通常は目標関数の偏微分を計算する必要がありますが、今回は説明の簡単さから考えて、その手前の偏微分を計算します。

![](images/0024.jpeg)

上記の式をもう少し分解してみます。(青字の部分)

![](images/0025.jpeg)

まず、パラメーター $b$ の偏微分を計算します。先程紹介したChain ruleで微分式を3つに分解することができます。

![](images/0033.jpeg)

先程の紹介したヤコビ行列の結果を参照することで最終結果を出すことができます。

ちなみに、最終結果の中にある「○」とは、アダマール積と言います。同じサイズの行列に対して成分ごとに積を取ることによって定まる行列の積です。

![](images/0034.jpeg)

次に、 パラメーターの$W$の偏微分を計算します。

![](images/0035.jpeg)

式を分解すると、それは $b$ の偏微分と似ています。

![](images/0036.jpeg)

計算の時だけではなくて、実装の時も同じ部分を1回のみ計算して重複使用しています。

![](images/0038.jpeg)

また、インプットの次元すは1, アウトプットの次元数は$n \times m$場合は、ヤコビ行列の結果は $1 \times n \times m$ になります。一方、パラメーター $W$ の次元数は $n \times m$ なので、これで後続の引き算ができません。そのため、勾配がパラメーターの次元数と同じようにしたいです。

![](images/0039.jpeg)

どうやってそれが達成できるのでしょうか。 結果としては $\delta^T x^T$ で計算するとそうなります。要は前の項は $\delta$ のことがわかります。後ろの項の計算結果は $x$ になるはずです。

![](images/0040.jpeg)

このスライドで説明する意図が分からなかったです。

![](images/0041.jpeg)

もともとの計算は転置がないですが、 $W$ の形に合わせるために転置の操作をいれました。

![](images/0042.jpeg)

ヤコビ行列の形がShape Conventionと違いますが、Assignment2のところで実装しやすいためにShape Conventionに沿ってやってください。

![](images/0043.jpeg)

実装する際に、ヤコビ行列で計算して、最後にShape Conventionの形に変換するのは一つのやり方です。こちらの方は実装上やりやすいです。もう一つのやり方としては常にShape Conventionにそってやることです。このやり方だと、いつもパラメーターの次元を意識しながら実装しないとエラーになるため、ややこしいです。

## 逆伝播

![](images/0044.jpeg)

今までの話は逆伝播に近いです。逆伝播は単純に微分して、微分の結果を用いてパラメーターをアップデートすることです。

前に話したもう一つのトリックとして、微分の結果を重複に使うことです。

![](images/0046.jpeg)

自動微分システムがあります。それはニューラルネットワークをグラフに表現して計算しています。グラフのソースノードはインプットです。中間のノードは各計算ステップです。エッジに沿って計算結果を渡します。

![](images/0047.jpeg)

このやり方で、順伝播(Forward Propagation)ができます。でも、逆伝播もしないといけないです。それは次のスライドから話します。

![](images/0048.jpeg)

逆伝播は順伝播と同じように、エッジに沿って、最終結果からソースノードへ逆方向に渡します。

![](images/0049.jpeg)

一個のノードを例として話します。 $h=f(z)$ の式について、そのノードは下流の勾配を受けて、上流に伝播します。

![](images/0051.jpeg)

そのノード自身の勾配もあるので、Chain ruleを利用して、勾配をアップデートして上流に渡します。

![](images/0052.jpeg)

基本的には下流の勾配を自身の勾配を掛け算して上流に渡します。

![](images/0054.jpeg)

上流に複数のノードがある場合は、ローカル勾配も複数用意して上流に渡します。

![](images/0057.jpeg)

一個シンプルな例で実際に計算します。例えば、右上の式と各パラメーターの値があります。それを各ステップに分解すると、式は左になり、その順伝播のグラフは下になります。

![](images/0060.jpeg)

まず、各ノードの勾配を算出します。その結果は右下の式になります。

![](images/0061.jpeg)

次に逆伝播します。最終の結果の勾配は1です。

![](images/0062.jpeg)

それを前に伝播すると計算結果は青字の通りになります。

![](images/0064.jpeg)

最終的に各エッジの勾配を算出することができます。

![](images/0065.jpeg)

これで、最終的結果に対するインプットの勾配も計算できます。

![](images/0067.jpeg)

上記の例にある $y$ は2つのノードから勾配を受けていますが、足し算で $y$ の勾配になります。

![](images/0068.jpeg)

また、微分の計算からにもわかりますが、足し算の場合は、下流の勾配は直接上流に流れます。

![](images/0069.jpeg)

Max計算の場合は、勾配は一個のノードへ渡して、もう一個は0です。

![](images/0070.jpeg)

掛け算の場合は、上流の2つのノードの勾配は順伝播の値の交換になります。

![](images/0072.jpeg)

それぞれのノードの別で計算するのは効率ではないです。

![](images/0073.jpeg)

効率のやり方としては、各ノードのローカル勾配を一括で計算して、前の計算結果を活かして後ろから一個一個計算して行くことです。

![](images/0074.jpeg)

上記のことの全体像はこのスライトにあります。このやり方の重要なところとしては、逆伝播と順伝播の計算量は同じ複雑度になります。

![](images/0075.jpeg)

また、それで自動微分システムも作れます。現在主流のTensorflowやPyTorchはこの仕組みを利用しています。

![](images/0076.jpeg)

こちらは自動微分システムを実装する際に全体像のPseudo codeです。

![](images/0078.jpeg)

全体の流れ以外、各種類のノードを手動で定義する必要があります。これは掛け算のコードです。

![](images/0079.jpeg)

後いくつかの補足があります。

実装したことが正しいかをチェックするために、直接インプットに小さい変化を与えて、アウトプットの変化は勾配に近いを見ることができます。

一方それはあくまでも近似するやり方ですし、計算も非常に遅いです。

![](images/0080.jpeg)

今回の授業は主に逆伝播のことを話しました。

逆伝播は、計算グラフに沿ってChain ruleを再帰的かつ効率的に適用します。下流の勾配が上流の勾配と局所勾配の積と等しくなります。

![](images/0081.jpeg)

PyTorch等の深層学習フレームワークがあるので、中身を実際に知る必要はありません。

しかし、このクラスでは、これらのことがどのように実装されているかを実際に学んでいることを期待しています。それにより、より深い理解を得ることができます。そして、時には深い理解が必要になることがあります。なぜなら、バックプロパゲーションは常に完全には機能しないからです。だから、それが実際に何をしているのかを理解することは、デバッグにとって非常に重要になることがあります。

(例えば、勾配爆発・消失のこと、また並列処理の問題を解決するには、今日学んだ知識が必要となってきます)